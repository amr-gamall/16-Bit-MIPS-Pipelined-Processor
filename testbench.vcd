$date
	Thu Jul  4 15:26:03 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb $end
$var wire 32 ! outputTest [31:0] $end
$var reg 3 " ALUControl [2:0] $end
$var reg 1 # ALUsrcA $end
$var reg 2 $ ALUsrcB [1:0] $end
$var reg 1 % IRWrite $end
$var reg 1 & IorD $end
$var reg 1 ' MemtoReg $end
$var reg 1 ( Memwrite $end
$var reg 1 ) PCEn $end
$var reg 1 * PCsrc $end
$var reg 1 + RegDst $end
$var reg 1 , RegWrite $end
$var reg 5 - addressTest [4:0] $end
$var reg 1 . clk $end
$var reg 1 / rst $end
$scope module dp $end
$var wire 3 0 ALUControl [2:0] $end
$var wire 1 # ALUsrcA $end
$var wire 2 1 ALUsrcB [1:0] $end
$var wire 1 % IRWrite $end
$var wire 1 & IorD $end
$var wire 1 ' MemtoReg $end
$var wire 1 ( Memwrite $end
$var wire 1 ) PCEn $end
$var wire 1 * PCsrc $end
$var wire 1 + RegDst $end
$var wire 1 , RegWrite $end
$var wire 5 2 addressTest [4:0] $end
$var wire 1 . clk $end
$var wire 1 / rst $end
$var wire 32 3 outputTest [31:0] $end
$var wire 32 4 dataOutput [31:0] $end
$var wire 32 5 btmp [31:0] $end
$var wire 32 6 atmp [31:0] $end
$var wire 32 7 SignImm [31:0] $end
$var wire 32 8 RwriteData [31:0] $end
$var wire 5 9 Radr [4:0] $end
$var wire 32 : PCPrime [31:0] $end
$var wire 32 ; PC [31:0] $end
$var wire 32 < Adr [31:0] $end
$var wire 32 = ALUResult [31:0] $end
$var reg 32 > A [31:0] $end
$var reg 32 ? ALUOut [31:0] $end
$var reg 32 @ B [31:0] $end
$var reg 32 A Data [31:0] $end
$var reg 32 B Instr [31:0] $end
$var reg 32 C SrcA [31:0] $end
$var reg 32 D SrcB [31:0] $end
$scope module a $end
$var wire 3 E ALUControl [2:0] $end
$var wire 32 F SrcA [31:0] $end
$var wire 32 G SrcB [31:0] $end
$var parameter 3 H add $end
$var parameter 3 I andd $end
$var parameter 3 J orr $end
$var parameter 3 K slt $end
$var parameter 3 L sub $end
$var reg 32 M ALUResult [31:0] $end
$upscope $end
$scope module m $end
$var wire 32 N address [31:0] $end
$var wire 1 . clk $end
$var wire 32 O dataOutput [31:0] $end
$var wire 32 P dataWrite [31:0] $end
$var wire 1 / rst $end
$var wire 1 ( writeEnable $end
$var integer 32 Q i [31:0] $end
$upscope $end
$scope module p $end
$var wire 1 . clk $end
$var wire 32 R dataInput [31:0] $end
$var wire 1 ) en $end
$var wire 1 / rst $end
$var reg 32 S dataOutput [31:0] $end
$upscope $end
$scope module r $end
$var wire 5 T addressA [4:0] $end
$var wire 5 U addressB [4:0] $end
$var wire 5 V addressTest [4:0] $end
$var wire 5 W addressWrite [4:0] $end
$var wire 1 . clk $end
$var wire 32 X dataWrite [31:0] $end
$var wire 1 / rst $end
$var wire 1 , writeEnable $end
$var reg 32 Y dataA [31:0] $end
$var reg 32 Z dataB [31:0] $end
$var reg 32 [ outputTest [31:0] $end
$var integer 32 \ i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b110 L
b111 K
b1 J
b0 I
b10 H
$end
#0
$dumpvars
b100000 \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
b0 S
bx R
b10000000000 Q
bx P
bx O
bx N
b0 M
b0 G
b0 F
bx E
b0 D
b0 C
bx B
bx A
bx @
bx ?
bx >
b0 =
bx <
b0 ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
1/
0.
bx -
x,
x+
x*
x)
x(
x'
x&
x%
bx $
x#
bx "
bx !
$end
#5000
b0 :
b0 R
bx D
bx G
b10001100000010100000000000100000 4
b10001100000010100000000000100000 O
b0 <
b0 N
b0 !
b0 3
b0 [
0*
b0 "
b0 0
b0 E
b0 $
b0 1
0#
0'
0+
0&
0)
0%
0,
0(
b1010 -
b1010 2
b1010 V
0/
#10000
b0 8
b0 X
b10001100000010100000000000100000 A
b0 ?
1.
#20000
b100 :
b100 R
b100 =
b100 M
b100 D
b100 G
b10 "
b10 0
b10 E
b1 $
b1 1
1)
1%
0.
#30000
b1000 :
b1000 R
b1000 =
b1000 M
b1010 9
b1010 W
b0 5
b0 Z
b0 6
b0 Y
b0 4
b0 O
b100 <
b100 N
b100 C
b100 F
b100 8
b100 X
b100000 7
b0 T
b1010 U
b100 ;
b100 S
b100 ?
b10001100000010100000000000100000 B
1.
#40000
bx :
bx R
bx =
bx M
bx D
bx G
0)
0%
b0 $
b0 1
0.
#50000
b100 :
b100 R
b100 =
b100 M
bx 8
bx X
b0 D
b0 G
b0 A
bx ?
b0 @
b0 P
b0 >
1.
#60000
b100000 :
b100000 R
b100000 =
b100000 M
b100000 D
b100000 G
b0 C
b0 F
b10 $
b10 1
1#
0.
#70000
b100000 8
b100000 X
b100000 ?
1.
#80000
b1010101010101010101010101010101 4
b1010101010101010101010101010101 O
b100000 <
b100000 N
1&
0.
#90000
b1010101010101010101010101010101 A
1.
#100000
b1010101010101010101010101010101 8
b1010101010101010101010101010101 X
1,
1'
0.
#110000
b1010101010101010101010101010101 5
b1010101010101010101010101010101 Z
b1010101010101010101010101010101 !
b1010101010101010101010101010101 3
b1010101010101010101010101010101 [
1.
#120000
0.
#130000
b1010101010101010101010101010101 @
b1010101010101010101010101010101 P
1.
#140000
0.
#150000
1.
#160000
0.
#170000
1.
#180000
0.
#190000
1.
#200000
0.
#210000
1.
#220000
0.
#230000
1.
#240000
0.
#250000
1.
